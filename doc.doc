/*

renvoie le nombre de caractere imprime

{color}%[flags][width][.precision][size]type

Type à gerer : d i o u x X c s p e f F g n b ib uz k

int: d & i B10;

Unsigned int:
b = binary code
o = B8;
u = B16;
x & X = B16, maj pour X;

Double: B10, Precision de 6 default;
e & E = Divise par la "dizaine", 42 = 4.200000e+01 ;
f & F = Precision de 6 apres le .;
g & G = si pas de . n'affiche rien;

unsigned char : c = 1 seule caractere;

const char * : s = string;

p = adress de la fct;

n = valeur du nombre de cara ecrit avant le %n et l'inscris dans la variable en param

b afficher en binaire

k date format ISO

Flags:
%% affiche le %
# "change de valeur" pour une B16 0x pour x OX pour X et 0 pour o 
+ ou - doit etre affiché devant le nombre
0 remplie par la gauche de 0, si 0 et - sont ensemble 0 est annulé
"space" espace avant le nombre positif, si negaitf pas despace
$ ?

{color} pour afficher en couleur

flags avec d i o u x X
-hh = char ou unsigned char
-h = short int ou unsigned short int
-l = long int ou unsigned short int
-ll = long long int ou unsigned long long int

flags avec e f g
-l = long int ou unsigned short int
-L = long double

.pre

for nb : ajouter des 0 devant si le chiffre nest pas assez grand
for letter : cut les lettres si cest trop grand ou ne fait rien si cest plus petit

*/


/*
** >>>GUIDE ON PRINTF OPTIONS<<<
**
** I_ Global Output
**
**      Printf reads the first param, which is always a string.
**  Any pattern in this string starting with  '%'  and recognized by printf will
**  be swapped with one of the next params. this param will take a specific form
**  (conversion) according to what is specified by the pattern (an int can be
**  converted into a given base, etc). By default, the first recognized pattern
**  will be swapped with the first param and so on.
**      The number of params must match the number of patterns. There must
**  not be unused params.
**
**      Once all of the patterns are swapped with converted params, the final
**  string is outputted standard output and the number of outputted char is
**  returned by the function.
**      In case of error, a negative value is returned.
**
**
** II_ Recognized Patterns
**
**  %[int$][flag][f_w(int\*[int$])][prec(.int\.*[int$])][l_modif]type (.)?
**
**  -> field_width : fixed int value (either written in the pattern or written
**  in the next param and referred to thanks to the  '*'  char). The diff with
**  the length of param will be padded according to the flag. If there is no
**  flag then the padding is filled with spaces and he param is aligned with the
**  right of the padding.
**
**  -> precision :   a  '.'  followed by a fixed int value.
**                  Or a  '.*'  which fetches the precision value in the next
**  param converted into an int.
**  With  '*'  , a negative value will be ignored. A precision of 0 will ignore
**  a 0 output.
**  . An int type will dipslay at least this amount of digits.
**  . A float type will display this amount of digit after the "float-point".
**  . A string type will display at most this amount of char.
**  . For a scientific conversion it will the number of significant digits.
**  (NB : you need  -  flag for negative int to be displayed with a
**  precision.)
**
**  -> length_modifier : a prefixe to type that specifies the size of the param.
**
**
** III_ Types printf can handle
**
**      Each of the following letter represents a type and allows printf to
**  know how to cast accordingly the parameters it takes.
**  -> c : the param is a char.
**  -> s : the param is a char* / string.
**  -> d : the param is an int ouputed in decimal base.
**  -> i : the param is an int ouputed in decimal base.
**  -> o : the param is an unsigned int converted in octal base.
**  -> u : the param is an unsigned int in decimal base.
**  -> x/X   : the param is an unsigned int converted to hexadecimal base.
**              (the abcdef chars of the base are capitalized or not if x is)
**  -> b     : the param is an unsigned int converted in binary base.
**  -> e/E   : the param is an int value in scientific notation.
**              (e = 10^ is capitalized if e is)
**  -> f/F   : the param is a float.
**  -> p : the param is the address of a pointer (void* type).
**  -> % : allows to output the  '%'  char.
**  -> C : the param is a unicode char.
**  -> S : the param is a string that is encoded in unicode.
**
**
** IV_ Available flags
**
**      Specifies how padding is made. More than one can be specified but there
**  can be 'unknown behaviours'
**  -> # :   adds a prefixe according to chosen base
**  -> 0 :   for int and float types the padding is filled with zeros
**              (ignored for none value type)
**  -> + :   outputs a positive sign to positive values.
**  -> - :   the param is aligned with the left of the padding.
**  -> ' '   :   the 'space' flag allows to output a space before positive
**              and empty values in signed values.
**              NB : is ignored when + flag is active
**
**
** V_ Length Modifier list
**
**  Type            d, i            b, B, o, u, x, X    n
**
**  Modifier
**  hh              signed char     unsigned char       signed char**
**  h               short           unsigned short      short**
**  l (ell)         long            unsigned long       long**
**  ll (ell ell)    long long       unsigned long long  long long**
**  j               intmax_t        uintmax_t           intmax_t**
**  t               ptrdiff_t       (see note)          ptrdiff_t**
**  z               (see note)      size_t              (see note)
**  q (deprecated)  quad_t          u_quad_t            quad_t**]
**
** VI_ The $ Flag
**
**      By default the param are treated the way they come but specifying an
**  int value m followed by  '$'  will call the param placed m in the list of
**  params. This can occur after  '%'  and  '*'  to choose the param you want.
**  If one $ (positional flag) is specified, all of the pattern must bear this
**  flag when invoking a param. One param can be referred to twice. If so, then
**  one less param is needed.
**  NB : this flag starts counting from one not zero.
**
**  Example :
**      printf("[%1$*2$d]", 4, 42);
**          Will output 4 padded in 42 spaces.
**          [                                          4]
